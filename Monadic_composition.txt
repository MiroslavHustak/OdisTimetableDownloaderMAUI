Result
(*
let defaultWith defaultFn res =
    match res with
    | Ok value  -> value
    | Error err -> defaultFn err 
        
let defaultValue default res =
    match res with
    | Ok value -> value
    | Error _  -> default
        
let map f res =
    match res with
    | Ok value  -> Ok (f value)
    | Error err -> Error err

let mapError f res =
    match res with
    | Ok value  -> Ok value
    | Error err -> Error (f err)

let bind f res =
    match res with
    | Ok value  -> f value
    | Error err -> Error err

type ResultBuilder() =
    member _.Return(value) = Ok value
    
    member _.ReturnFrom(m: Result<_,_>) = m
    
    member _.Bind(m: Result<'T,'E>, binder: 'T -> Result<'U,'E>) : Result<'U,'E> =
        match m with
        | Ok v -> binder v
        | Error e -> Error e
    
    member _.Zero() = Ok ()
    
    member _.Combine(m: Result<unit,'E>, binder: unit -> Result<'T,'E>) =
        match m with
        | Ok () -> binder()
        | Error e -> Error e
    
    member _.Delay(f: unit -> _) = f
    
    member _.Run(f) = f()
    
    member _.TryWith(body: unit -> Result<'T,'E>, catchHandler: exn -> Result<'T,'E>) =
        try
            body()
        with ex -> catchHandler ex
    
    member _.TryFinally(body: unit -> Result<'T,'E>, compensation: unit -> unit) =
        try
            body()
        finally
            compensation()
    
    member _.Using(resource: 'T :> IDisposable, binder: 'T -> Result<'U,'E>) =
        use res = resource
        binder res
    
    member _.While(guard: unit -> bool, body: unit -> Result<unit,'E>) : Result<unit,'E> =
        if not (guard()) then Ok () else
        match body() with
        | Ok () -> _.While(guard, body)
        | Error e -> Error e
    
    member _.For(sequence: seq<'T>, binder: 'T -> Result<unit,'E>) : Result<unit,'E> =
        use e = sequence.GetEnumerator()
        let rec loop() =
            if e.MoveNext() then
                match binder e.Current with
                | Ok () -> loop()
                | Error e -> Error e
            else Ok ()
        loop()

// The instance everyone uses
let result = ResultBuilder()

let saveUser user =
    result
        {
            do! validateUser user
            do! UserRepository.save user
            return user.Id
        }
    |> Result.mapError (fun err -> DomainError.Validation err)  
*)

Option
(*
let defaultValue default opt =
    match opt with
    | Some value -> value
    | None       -> default
        
let map f opt =
    match opt with
    | Some value -> Some (f value)
    | None       -> None

let bind f opt =
    match opt with
    | Some value -> f value
    | None       -> None
*) 

option
    {
        let! nodes = htmlNode.InnerText () |> Option.ofNullEmpty
        let! attr = attr.Value () |> Option.ofNullEmpty
                                                               
        return (nodes, attr)
    }       

is the equivalent of: 
    
 pyramidOfDoom with Some and None
    {
        let! nodes = htmlNode.InnerText () |> Option.ofNullEmpty, None
        let! attr = attr.Value () |> Option.ofNullEmpty, None
                                                               
        return Some (nodes, attr)
    }         

*****************************************

let downloadAndSaveJson reportProgress (token : CancellationToken) = 

    let errFn err =  
        match err with
        | JsonDownloadError    -> jsonDownloadError
        | JsonConnectionError  -> cancelMsg2
        | NetConnJsonError err -> err
        | JsonTimeoutError     -> jsonDownloadError  
        | StopJsonDownloading  -> String.Empty
                    
    try
       //some code
    with
    | _ -> Error JsonDownloadError  
                 
    |> function
        | Ok _      -> Ok dispatchMsg1 
        | Error err -> Error <| errFn err

let downloadAndSaveJson reportProgress (token : CancellationToken) = 

    let errFn err =  
        match err with
        | JsonDownloadError    -> jsonDownloadError
        | JsonConnectionError  -> cancelMsg2
        | NetConnJsonError err -> err
        | JsonTimeoutError     -> jsonDownloadError  
        | StopJsonDownloading  -> jsonCancel
                    
    try
        //some code
    with
    | _ -> Error JsonDownloadError  
    
    |> Result.map (fun _ -> dispatchMsg1) 
    |> Result.mapError errFn

**************************************************************************************************
document.Descendants "a"
|> Seq.choose 
    (fun htmlNode ->
        match htmlNode.TryGetAttribute "href" with
        | Some attr 
            ->
            pyramidOfDoom
                {
                    let! nodes = htmlNode.InnerText () |> Option.ofNullEmpty, None
                    let! attr = attr.Value () |> Option.ofNullEmpty, None
                                                               
                    return Some (nodes, attr)
                }         
        | None
            ->
            None
    )

document.Descendants "a"
|> Seq.choose 
    (fun htmlNode
        ->
        htmlNode.TryGetAttribute "href" //inner text zatim nepotrebuji, cisla linek mam resena jinak  
        |> Option.bind
            (fun attr
                -> 
                pyramidOfDoom
                    {
                        let! nodes = htmlNode.InnerText () |> Option.ofNullEmpty, None
                        let! attr = attr.Value () |> Option.ofNullEmpty, None
                                                               
                        return Some (nodes, attr)
                    }                                                          
            )            
    )  

document.Descendants "a"
|> Seq.choose 
    (fun htmlNode
        ->
        htmlNode.TryGetAttribute "href" //inner text zatim nepotrebuji, cisla linek mam resena jinak  
        |> Option.bind
            (fun attr
                -> 
                option
                    {
                        let! nodes = htmlNode.InnerText () |> Option.ofNullEmpty
                        let! attr = attr.Value () |> Option.ofNullEmpty
                                                               
                        return (nodes, attr)
                    }                                                          
            )            
    )  

************************************************************************
filterTimetables 
|> List.mapi
    (fun i (link, pathToFile)
        ->  
        //Some code
    ) 
|> ignore
|> Ok

filterTimetables 
|> List.mapi
    (fun i (link, pathToFile) ->  
        //Some code
    ) 
|> List.tryPick
    (function
        | Ok _ -> None
        | Error err ->
            match (string err.Message).Contains("The operation was canceled.") with
            | true  -> Some <| Error StopDownloadingMHD
            | false -> Some <| Error FileDownloadErrorMHD
    )
|> function
    | Some value -> value
    | None -> Ok ()

filterTimetables 
|> List.mapi
    (fun i (link, pathToFile)
        ->  
        //Some code
    ) 
|> List.tryPick
    (function
        | Ok _ 
            -> 
            None

        | Error err
            ->
            match (string err.Message).Contains("The operation was canceled.") with
            | true  -> Some <| Error StopDownloadingMHD
            | false -> Some <| Error FileDownloadErrorMHD
    )
|> Option.defaultValue (Ok ()) 

******************************************************************************

let internal digThroughJsonStructure (token : CancellationToken) = //prohrabeme se strukturou json souboru 
        
    let kodisTimetables (token : CancellationToken) : Reader<string list, string seq> =
        
        reader  //Reader monad for educational purposes only, no real benefit here  
            {
                let! pathToJsonList = fun env -> env
        
                return 
                    //some code
                            |> Option.ofNull
                            |> function
                                | Some value -> value |> Seq.map (_.Timetable)
                                | None       -> Seq.empty
                        )
            }

let internal digThroughJsonStructure (token : CancellationToken) = //prohrabeme se strukturou json souboru 
        
    let kodisTimetables (token : CancellationToken) : Reader<string list, string seq> =
        
        reader  //Reader monad for educational purposes only, no real benefit here  
            {
                let! pathToJsonList = fun env -> env
        
                return 
                    //some code
                            |> Option.ofNull
                            |> Option.map (Seq.map _.Timetable)
                            |> Option.defaultValue Seq.empty  //TODO logfile
                        )
            }
            
let kodisTimetables3 : Reader<string list, string seq> = 

    reader //Reader monad for educational purposes only, no real benefit here  
        {
            let! pathToJsonList3 = fun env -> env 

            return 
                pathToJsonList3 
                |> Seq.ofList 
                |> Seq.collect 
                    (fun pathToJson 
                        ->    
                        let kodisJsonSamples =    
                            //Some code                     
                                 
                        let timetables = 
                            kodisJsonSamples
                            |> Option.ofNull
                            |> function 
                                | Some value -> value.Data |> Seq.map _.Timetable  //nejde Some, nejde Ok
                                | None       -> Seq.empty  //TODO logfile
                                 
                        let vyluky = 
                            kodisJsonSamples
                            |> Option.ofNull
                            |> function 
                                | Some value -> value.Data |> Seq.collect _.Vyluky  //nejde Some, nejde Ok
                                | None       -> Seq.empty  //TODO logfile
                                 
                        let attachments = 
                            vyluky
                            |> Option.ofNull 
                            |> function
                                | Some value
                                    ->
                                   //Some code

                                | None   
                                    ->
                                    Seq.empty  //TODO logfile

                        Seq.append timetables attachments   
                    )  
        }  
        
let kodisTimetables3 : Reader<string list, string seq> = 

    reader //Reader monad for educational purposes only, no real benefit here  
        {
            let! pathToJsonList3 = fun env -> env 

            return 
                pathToJsonList3 
                |> Seq.ofList 
                |> Seq.collect 
                    (fun pathToJson 
                        ->    
                        let kodisJsonSamples =    
                            //Some code                        
                                 
                        let timetables = 
                            kodisJsonSamples
                            |> Option.ofNull
                            |> Option.map (fun value -> value.Data |> Seq.map _.Timetable)
                            |> Option.defaultValue Seq.empty  //TODO logfile                                 
                                 
                        let vyluky = 
                            kodisJsonSamples
                            |> Option.ofNull
                            |> Option.map (fun value -> value.Data |> Seq.collect _.Vyluky)
                            |> Option.defaultValue Seq.empty //TODO logfile
                                 
                        let attachments = 
                            vyluky
                            |> Option.ofNull
                            |> Option.map
                                (fun value
                                    -> 
                                    value
                                    |> Seq.collect _.Attachments
                                    |> List.ofSeq
                                    |> List.Parallel.map (fun item -> item.Url |> Option.ofNullEmptySpace)
                                    |> List.choose id  // Remove `None` values
                                    |> List.toSeq
                                )
                            |> Option.defaultValue Seq.empty  //TODO logfile

                        Seq.append timetables attachments   
                    )  
        }    
         
let kodisAttachments : Reader<string list, string seq> = //Reader monad for educational purposes only, no real benefit here
            
    reader 
        {
            let! pathToJsonList = fun env -> env 
                        
            return                          
                pathToJsonList
                |> Seq.ofList 
                |> Seq.collect  //vzhledem ke komplikovanosti nepouzivam Result.sequence pro Array.collect (po zmene na seq ocekavam to same), nejde Some, nejde Ok jako vyse
                    (fun pathToJson 
                        -> 
                        let fn1 (value : JsonProvider1.Attachment seq) = 
                            //Some code

                        let fn2 (item : JsonProvider1.Vyluky) =    
                            item.Attachments 
                            |> Option.ofNull        
                            |> function 
                                | Some value -> value |> fn1
                                | None       -> Seq.empty  //TODO logfile              

                        let fn3 (item : JsonProvider1.Root) =  
                            item.Vyluky
                            |> Option.ofNull  
                            |> function 
                                | Some value -> value |> Seq.collect fn2 
                                | None       -> Seq.empty  //TODO logfile     

                        let kodisJsonSamples = 
                            //Some code
                                                          
                        kodisJsonSamples 
                        |> Option.ofNull
                        |> function 
                            | Some value -> value |> Seq.collect fn3 
                            | None       -> Seq.empty   //TODO logfile                                 
                    ) 
        }

let kodisAttachments : Reader<string list, string seq> = //Reader monad for educational purposes only, no real benefit here
            
    reader 
        {
            let! pathToJsonList = fun env -> env 
                        
            return                          
                pathToJsonList
                |> Seq.ofList 
                |> Seq.collect  //vzhledem ke komplikovanosti nepouzivam Result.sequence pro Array.collect (po zmene na seq ocekavam to same), nejde Some, nejde Ok jako vyse
                    (fun pathToJson 
                        -> 
                        let fn1 (value : JsonProvider1.Attachment seq) = 
                           //Some code

                        let fn2 (item : JsonProvider1.Vyluky) =    
                            item.Attachments 
                            |> Option.ofNull        
                            |> Option.map fn1
                            |> Option.defaultValue Seq.empty  //TODO logfile       

                        let fn3 (item : JsonProvider1.Root) =  
                            item.Vyluky
                            |> Option.ofNull  
                            |> Option.map (Seq.collect fn2)
                            |> Option.defaultValue Seq.empty //TODO logfile  

                        let kodisJsonSamples = 
                           //Some code
                                                          
                        kodisJsonSamples
                        |> Option.ofNull
                        |> Option.map (Seq.collect fn3)
                        |> Option.defaultValue Seq.empty //TODO logfile                        
                    ) 
        }
        
**************************************************************************
let internal checkFileCondition pathToFile condition =
        
    pyramidOfDoom
        {
            let filepath = pathToFile |> Path.GetFullPath |> Option.ofNullEmpty 
            let! filepath = filepath, None
                    
            let fInfodat : FileInfo = FileInfo filepath
            let! _ = condition fInfodat |> Option.ofBool, None  
                                                 
            return Some ()
        }        

let internal checkFileCondition pathToFile condition =
        
    option
        {
            let! filepath = pathToFile |> Path.GetFullPath |> Option.ofNullEmpty                     
            let fInfodat : FileInfo = FileInfo filepath

            return! condition fInfodat |> Option.ofBool  
        }     
        

let internal readAllTextAsync path = 

    pyramidOfDoom
        {   
            let! filepath = Path.GetFullPath path |> Option.ofNullEmpty, Error JsonDownloadError
            let fInfoDat = FileInfo filepath
            let! _ = fInfoDat.Exists |> Option.ofBool, Error JsonDownloadError

            return Ok (File.ReadAllTextAsync filepath |> Async.AwaitTask)                                          
        }  
            
    |> function
        | Ok value -> value                      
        | Error _  -> async { return jsonEmpty } 

 let internal readAllTextAsync path = 

    pyramidOfDoom
        {   
            let! filepath = Path.GetFullPath path |> Option.ofNullEmpty, Error JsonDownloadError
            let fInfoDat = FileInfo filepath
            let! _ = fInfoDat.Exists |> Option.ofBool, Error JsonDownloadError

            return Ok (File.ReadAllTextAsync filepath |> Async.AwaitTask)                                          
        }  
            
    |> Result.defaultWith (fun _ -> async { return jsonEmpty }) 


*******************************************************************************************
From REST API solution
*******************************************************************************************

let getJsonStringAsync path =

    try
        pyramidOfDoom 
            {
                //some code                
                return Ok (reader, fs)
            }

        |> function
            | Ok (reader, fs) 
                ->
                async
                    { 
                        //some async code
                        return json 
                    }
                |> Ok
                       
            | Error err -> Error err
            
    with
    | ex -> Error (string ex.Message)


let getJsonStringAsync path =

    try
        pyramidOfDoom 
            {
               //some code
                return Ok (reader, fs)
            }

        |> Result.map 
            (fun (reader, fs) 
                -> 
                async
                    { 
                        //some async code
                        return json 
                    }
            ) 
                
    with
    | ex -> Error (string ex.Message)

********************************************************
 let jsonString = 
    jsonString 
    |> Option.ofNull 
    |> function
        | Some value -> value
        | None       -> jsonEmpty 

 let jsonString = 
    jsonString 
    |> Option.ofNull 
    |> Option.defaultValue jsonEmpty 

********************************************************

Dalsi educational code: //TODO dej ho jinde

(*
//There is no need for Async.OnCancel handlers to dispose of resources as the use block will automatically clean up resources

let! clientCancellationHandler = Async.OnCancel <| fun () -> client.Dispose()        
clientCancellationHandler.Dispose()        

let! fileStreamCancellationHandler = Async.OnCancel <| fun () -> fileStream.Dispose()        
fileStreamCancellationHandler.Dispose()

let! responseCancellationHandler = Async.OnCancel <| fun () -> response.Dispose()        
responseCancellationHandler.Dispose()
*)

 
(*
//There is no need for Async.OnCancel handlers to dispose of resources as the use block will automatically clean up resources
                                                                       
let! clientCancellationHandler = Async.OnCancel <| fun () -> client.Dispose()        
clientCancellationHandler.Dispose()                                    

let! responseCancellationHandler = Async.OnCancel <| fun () -> response.Dispose()        
responseCancellationHandler.Dispose()
*)

async
    {
        try
            return!
                asyncResult
                    {
                        let! _ = checkFileSize () |> Result.fromOption
                        let! asyncWriter = prepareJsonAsyncAppend ()

                        return! asyncWriter |> AsyncResult.ofAsync
                    }
        with
        |_ -> return Error String.Empty
    }
|> Async.RunSynchronously

(*
async
    {
        try
            match checkFileSize () with
            | Some _
                ->
                match prepareJsonAsyncAppend () with
                | Ok asyncWriter
                    ->
                    do! asyncWriter
                    return Ok ()

                | Error _
                    ->
                    return Error String.Empty

            | None
                ->
                return Error String.Empty
        with
        | _ -> return Error String.Empty
    }
|> Async.RunSynchronously
*)
let prepareJsonAsyncWrite () = // it only prepares an asynchronous operation that writes the json string
     
    try  
        pyramidOfDoom //nelze option CE (TODO: look at the definition code to find out why)
            {                   
                let! path = Path.GetFullPath path |> Option.ofNullEmpty, None  
                                              
                let pathOption =
                    File.Exists path
                    |> Option.fromBool path
                    |> Option.orElseWith 
                        (fun ()
                            ->
                            File.WriteAllText(path, jsonEmpty)
                            Some path
                        ) 

                let! path = pathOption, None 
                                                            
                let writer = new StreamWriter(path, false)                
                let!_ = writer |> Option.ofNull, None
                                                                                
                return Some writer
            }         
                     
        |> Option.map 
            (fun (writer : StreamWriter) 
                ->
                async
                    {
                        use writer = writer
                        do! writer.WriteAsync json |> Async.AwaitTask

                        return! writer.FlushAsync() |> Async.AwaitTask
                    }
            )
    with
    | _ -> None

    async
        {
            try    
                match prepareJsonAsyncWrite () with
                | Some asyncWriter     
                    ->
                    do! asyncWriter    
                    return Ok ()

                | None
                    ->                              
                    return Error "StreamWriter Error" 
            with
            | ex -> return Error (string ex.Message) 
        }   
    |> Async.RunSynchronously 